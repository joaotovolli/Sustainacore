from __future__ import annotations

import logging
import os
import re
from datetime import datetime

import oracledb

from core.oracle_db import get_connection

JOB_TABLE = "PROC_GEMINI_JOBS"
APPROVAL_TABLE = "PROC_GEMINI_APPROVALS"
RESEARCH_REQUEST_TABLE = "PROC_RESEARCH_REQUESTS"

logger = logging.getLogger(__name__)


def _materialize_value(value):
    if hasattr(value, "read"):
        return value.read()
    return value


def _normalize_oracle_scalar(value):
    if isinstance(value, (list, tuple)):
        return value[0] if value else None
    return value


def _table_exists(cursor: oracledb.Cursor, table_name: str) -> bool:
    cursor.execute(
        "SELECT COUNT(1) FROM user_tables WHERE table_name = :name",
        {"name": table_name.upper()},
    )
    return cursor.fetchone()[0] > 0


def _column_exists(cursor: oracledb.Cursor, table_name: str, column_name: str) -> bool:
    cursor.execute(
        """
        SELECT COUNT(1)
        FROM user_tab_columns
        WHERE table_name = :table_name AND column_name = :column_name
        """,
        {"table_name": table_name.upper(), "column_name": column_name.upper()},
    )
    return cursor.fetchone()[0] > 0


def get_current_schema() -> str | None:
    if not (os.getenv("DB_USER") or os.getenv("ORACLE_USER")):
        return None
    try:
        with get_connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA') FROM dual")
                row = cursor.fetchone()
                return row[0] if row else None
    except Exception:
        logger.exception("proc_oracle.schema_lookup_failed")
        return None


def ensure_proc_tables_exist() -> None:
    ddl_jobs = f"""
    CREATE TABLE {JOB_TABLE} (
        JOB_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        ROUTINE_CODE VARCHAR2(50),
        ROUTINE_LABEL VARCHAR2(200),
        CONTENT_TEXT CLOB,
        INSTRUCTIONS CLOB NOT NULL,
        FILE_NAME VARCHAR2(512),
        FILE_MIME VARCHAR2(128),
        FILE_BLOB BLOB,
        STATUS VARCHAR2(30),
        CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
        UPDATED_AT TIMESTAMP,
        RESULT_TEXT CLOB,
        ERROR_TEXT CLOB
    )
    """

    ddl_approvals = f"""
    CREATE TABLE {APPROVAL_TABLE} (
        APPROVAL_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        SOURCE_JOB_ID NUMBER,
        REQUEST_TYPE VARCHAR2(50),
        TITLE VARCHAR2(512),
        PROPOSED_TEXT CLOB,
        DETAILS CLOB,
        GEMINI_COMMENTS CLOB,
        FILE_NAME VARCHAR2(512),
        FILE_MIME VARCHAR2(128),
        FILE_BLOB BLOB,
        STATUS VARCHAR2(30),
        CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
        DECIDED_AT TIMESTAMP,
        DECIDED_BY VARCHAR2(256),
        DECISION_NOTES CLOB
    )
    """

    with get_connection() as conn:
        with conn.cursor() as cursor:
            if not _table_exists(cursor, JOB_TABLE):
                cursor.execute(ddl_jobs)
            if not _table_exists(cursor, APPROVAL_TABLE):
                cursor.execute(ddl_approvals)
            elif not _column_exists(cursor, APPROVAL_TABLE, "GEMINI_COMMENTS"):
                cursor.execute(f"ALTER TABLE {APPROVAL_TABLE} ADD (GEMINI_COMMENTS CLOB)")
        conn.commit()


def insert_job(
    *,
    routine_code: str,
    routine_label: str,
    content_text: str | None,
    instructions: str,
    file_name: str | None,
    file_mime: str | None,
    file_blob: bytes | None,
) -> int:
    sql = f"""
        INSERT INTO {JOB_TABLE} (
            ROUTINE_CODE,
            ROUTINE_LABEL,
            CONTENT_TEXT,
            INSTRUCTIONS,
            FILE_NAME,
            FILE_MIME,
            FILE_BLOB,
            STATUS,
            CREATED_AT,
            UPDATED_AT
        )
        VALUES (
            :routine_code,
            :routine_label,
            :content_text,
            :instructions,
            :file_name,
            :file_mime,
            :file_blob,
            :status,
            SYSTIMESTAMP,
            SYSTIMESTAMP
        )
        RETURNING JOB_ID INTO :job_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            job_id_var = cursor.var(oracledb.NUMBER)
            cursor.setinputsizes(
                content_text=oracledb.DB_TYPE_CLOB,
                instructions=oracledb.DB_TYPE_CLOB,
            )
            cursor.execute(
                sql,
                {
                    "routine_code": routine_code,
                    "routine_label": routine_label,
                    "content_text": content_text,
                    "instructions": instructions,
                    "file_name": file_name,
                    "file_mime": file_mime,
                    "file_blob": oracledb.Binary(file_blob) if file_blob else None,
                    "status": "PENDING",
                    "job_id": job_id_var,
                },
            )
        conn.commit()
        return int(_normalize_oracle_scalar(job_id_var.getvalue()))


def list_recent_jobs(limit: int = 10, include_handed_off: bool = False) -> list[dict[str, object]]:
    status_filter = "UPPER(TRIM(j.STATUS)) IN ('PENDING','IN_PROGRESS')"
    archive_filter = "(j.RESULT_TEXT IS NULL OR UPPER(j.RESULT_TEXT) NOT LIKE 'ARCHIVED%')"
    approval_join = f"""
        LEFT JOIN {APPROVAL_TABLE} a
            ON a.SOURCE_JOB_ID = j.JOB_ID
            AND UPPER(TRIM(a.STATUS)) IN ('PENDING','APPROVED','REJECTED')
    """
    approval_filter = "" if include_handed_off else "AND a.APPROVAL_ID IS NULL"
    sql = f"""
        SELECT * FROM (
            SELECT j.JOB_ID, j.ROUTINE_LABEL, j.STATUS, j.CREATED_AT, j.FILE_NAME
            FROM {JOB_TABLE} j
            {approval_join}
            WHERE {status_filter}
              AND {archive_filter}
              {approval_filter}
            ORDER BY j.CREATED_AT DESC
        ) WHERE ROWNUM <= :limit
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"limit": limit})
            rows = cursor.fetchall()
    return [
        {
            "job_id": row[0],
            "routine_label": row[1],
            "status": row[2],
            "created_at": row[3],
            "file_name": row[4],
        }
        for row in rows
    ]


def list_pending_approvals(limit: int = 50) -> list[dict[str, object]]:
    with get_connection() as conn:
        with conn.cursor() as cursor:
            has_comments = _column_exists(cursor, APPROVAL_TABLE, "GEMINI_COMMENTS")
            comments_select = (
                "DBMS_LOB.SUBSTR(GEMINI_COMMENTS, 2000, 1) AS GEMINI_COMMENTS_PREVIEW"
                if has_comments
                else "CAST(NULL AS VARCHAR2(2000)) AS GEMINI_COMMENTS_PREVIEW"
            )
            sql = f"""
                SELECT * FROM (
                    SELECT APPROVAL_ID,
                           SOURCE_JOB_ID,
                           REQUEST_TYPE,
                           TITLE,
                           CREATED_AT,
                           FILE_NAME,
                           FILE_MIME,
                           DBMS_LOB.SUBSTR(PROPOSED_TEXT, 2000, 1) AS PROPOSED_TEXT_PREVIEW,
                           DBMS_LOB.SUBSTR(DETAILS, 2000, 1) AS DETAILS_PREVIEW,
                           {comments_select},
                           DBMS_LOB.SUBSTR(DECISION_NOTES, 2000, 1) AS DECISION_NOTES_PREVIEW
                    FROM {APPROVAL_TABLE}
                    WHERE UPPER(TRIM(STATUS)) = 'PENDING'
                      AND (DECISION_NOTES IS NULL OR UPPER(DECISION_NOTES) NOT LIKE 'ARCHIVED%')
                    ORDER BY CREATED_AT DESC, APPROVAL_ID DESC
                ) WHERE ROWNUM <= :limit
            """
            try:
                cursor.execute(sql, {"limit": limit})
                rows = cursor.fetchall()
            except Exception:
                logger.exception("proc_oracle.list_pending_approvals_failed")
                raise
    results = []
    for row in rows:
        summary_source = row[3] or row[7] or row[8] or row[9] or row[10] or ""
        results.append(
            {
                "approval_id": row[0],
                "source_job_id": row[1],
                "request_type": row[2],
                "title": row[3],
                "created_at": row[4],
                "file_name": row[5],
                "file_mime": row[6],
                "proposed_text_preview": row[7] or "",
                "details_preview": row[8] or "",
                "gemini_comments_preview": row[9] or "",
                "decision_notes_preview": row[10] or "",
                "summary": summary_source,
            }
        )
    return results


def get_approval(approval_id: int) -> dict[str, object] | None:
    with get_connection() as conn:
        with conn.cursor() as cursor:
            has_comments = _column_exists(cursor, APPROVAL_TABLE, "GEMINI_COMMENTS")
            comments_select = (
                "DBMS_LOB.SUBSTR(GEMINI_COMMENTS, 4000, 1) AS GEMINI_COMMENTS"
                if has_comments
                else "CAST(NULL AS VARCHAR2(4000)) AS GEMINI_COMMENTS"
            )
            sql = f"""
                SELECT APPROVAL_ID,
                       SOURCE_JOB_ID,
                       REQUEST_TYPE,
                       TITLE,
                       DBMS_LOB.SUBSTR(PROPOSED_TEXT, 4000, 1) AS PROPOSED_TEXT,
                       DBMS_LOB.SUBSTR(DETAILS, 4000, 1) AS DETAILS,
                       {comments_select},
                       FILE_NAME,
                       FILE_MIME,
                       STATUS,
                       CREATED_AT,
                       DECIDED_AT,
                       DECIDED_BY,
                       DBMS_LOB.SUBSTR(DECISION_NOTES, 4000, 1) AS DECISION_NOTES
                FROM {APPROVAL_TABLE}
                WHERE APPROVAL_ID = :approval_id
            """
            cursor.execute(sql, {"approval_id": approval_id})
            row = cursor.fetchone()
            if not row:
                return None
    return {
        "approval_id": row[0],
        "source_job_id": row[1],
        "request_type": row[2],
        "title": row[3],
        "proposed_text": row[4],
        "details": row[5],
        "gemini_comments": row[6],
        "file_name": row[7],
        "file_mime": row[8],
        "status": row[9],
        "created_at": row[10],
        "decided_at": row[11],
        "decided_by": row[12],
        "decision_notes": row[13],
    }


def get_job(job_id: int) -> dict[str, object] | None:
    sql = f"""
        SELECT JOB_ID, ROUTINE_CODE, ROUTINE_LABEL, CONTENT_TEXT, INSTRUCTIONS,
               FILE_NAME, FILE_MIME, FILE_BLOB, STATUS, CREATED_AT
        FROM {JOB_TABLE}
        WHERE JOB_ID = :job_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"job_id": job_id})
            row = cursor.fetchone()
            if not row:
                return None
            materialized = [_materialize_value(value) for value in row]
    return {
        "job_id": materialized[0],
        "routine_code": materialized[1],
        "routine_label": materialized[2],
        "content_text": materialized[3],
        "instructions": materialized[4],
        "file_name": materialized[5],
        "file_mime": materialized[6],
        "file_blob": materialized[7],
        "status": materialized[8],
        "created_at": materialized[9],
    }


def get_job_file(job_id: int) -> dict[str, object] | None:
    sql = f"""
        SELECT FILE_NAME, FILE_MIME, FILE_BLOB
        FROM {JOB_TABLE}
        WHERE JOB_ID = :job_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"job_id": job_id})
            row = cursor.fetchone()
            if not row or not row[2]:
                return None
            materialized = [_materialize_value(value) for value in row]
    return {
        "file_name": materialized[0],
        "file_mime": materialized[1],
        "file_blob": materialized[2],
    }


def get_approval_file(approval_id: int) -> dict[str, object] | None:
    sql = f"""
        SELECT FILE_NAME, FILE_MIME, FILE_BLOB
        FROM {APPROVAL_TABLE}
        WHERE APPROVAL_ID = :approval_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"approval_id": approval_id})
            row = cursor.fetchone()
            if not row or not row[2]:
                return None
            materialized = [_materialize_value(value) for value in row]
    return {
        "file_name": materialized[0],
        "file_mime": materialized[1],
        "file_blob": materialized[2],
    }


def decide_approval(
    *,
    approval_id: int,
    status: str,
    decided_by: str,
    decision_notes: str | None,
) -> int:
    sql = f"""
        UPDATE {APPROVAL_TABLE}
        SET STATUS = :status,
            DECIDED_AT = SYSTIMESTAMP,
            DECIDED_BY = :decided_by,
            DECISION_NOTES = CASE
                WHEN :decision_notes IS NULL THEN DECISION_NOTES
                WHEN DECISION_NOTES IS NULL THEN :decision_notes
                ELSE DECISION_NOTES || CHR(10) || :decision_notes
            END
        WHERE APPROVAL_ID = :approval_id
          AND UPPER(TRIM(STATUS)) = 'PENDING'
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.setinputsizes(decision_notes=oracledb.DB_TYPE_CLOB)
            cursor.execute(
                sql,
                {
                    "status": status,
                    "decided_by": decided_by,
                    "decision_notes": decision_notes,
                    "approval_id": approval_id,
                },
            )
            updated = cursor.rowcount
        conn.commit()
    return updated or 0


def update_job_superseded(job_id: int, new_job_id: int) -> None:
    sql = f"""
        UPDATE {JOB_TABLE}
        SET STATUS = 'DONE',
            UPDATED_AT = SYSTIMESTAMP,
            RESULT_TEXT = CASE
                WHEN RESULT_TEXT IS NULL THEN :note
                ELSE RESULT_TEXT || CHR(10) || :note
            END
        WHERE JOB_ID = :job_id
    """
    note = f"SUPERSEDED by job_id={new_job_id}"
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.setinputsizes(note=oracledb.DB_TYPE_CLOB)
            cursor.execute(
                sql,
                {
                    "note": note,
                    "job_id": job_id,
                },
            )
        conn.commit()


def list_recent_decisions(limit: int = 50) -> list[dict[str, object]]:
    sql = f"""
        SELECT * FROM (
            SELECT APPROVAL_ID,
                   REQUEST_TYPE,
                   TITLE,
                   STATUS,
                   DECIDED_AT,
                   DECIDED_BY,
                   DBMS_LOB.SUBSTR(DECISION_NOTES, 2000, 1) AS DECISION_NOTES_PREVIEW,
                   DBMS_LOB.SUBSTR(DETAILS, 2000, 1) AS DETAILS_PREVIEW
            FROM {APPROVAL_TABLE}
            WHERE UPPER(TRIM(STATUS)) IN ('APPROVED', 'REJECTED')
            ORDER BY DECIDED_AT DESC NULLS LAST, CREATED_AT DESC
        ) WHERE ROWNUM <= :limit
    """
    try:
        with get_connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute(sql, {"limit": limit})
                rows = cursor.fetchall()
    except Exception:
        logger.exception("proc_oracle.list_recent_decisions_failed")
        raise
    results = []
    for row in rows:
        notes_preview = row[6] or ""
        details_preview = row[7] or ""
        applied = "APPLIED" in f"{notes_preview} {details_preview}".upper()
        results.append(
            {
                "approval_id": row[0],
                "request_type": row[1],
                "title": row[2],
                "status": row[3],
                "decided_at": row[4],
                "decided_by": row[5],
                "applied": applied,
            }
        )
    return results


def create_research_request(
    *,
    request_type: str,
    company_ticker: str | None,
    window_start: datetime | None,
    window_end: datetime | None,
    editor_notes: str | None,
    source_approval_id: int | None,
    created_by: str,
) -> int:
    sql = f"""
        INSERT INTO {RESEARCH_REQUEST_TABLE} (
            STATUS,
            REQUEST_TYPE,
            COMPANY_TICKER,
            WINDOW_START,
            WINDOW_END,
            EDITOR_NOTES,
            SOURCE_APPROVAL_ID,
            CREATED_BY,
            CREATED_AT,
            UPDATED_AT
        )
        VALUES (
            :status,
            :request_type,
            :company_ticker,
            :window_start,
            :window_end,
            :editor_notes,
            :source_approval_id,
            :created_by,
            SYSTIMESTAMP,
            SYSTIMESTAMP
        )
        RETURNING REQUEST_ID INTO :request_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            request_id_var = cursor.var(oracledb.NUMBER)
            cursor.setinputsizes(editor_notes=oracledb.DB_TYPE_CLOB)
            cursor.execute(
                sql,
                {
                    "status": "PENDING",
                    "request_type": request_type,
                    "company_ticker": company_ticker,
                    "window_start": window_start,
                    "window_end": window_end,
                    "editor_notes": editor_notes,
                    "source_approval_id": source_approval_id,
                    "created_by": created_by,
                    "request_id": request_id_var,
                },
            )
        conn.commit()
        return int(_normalize_oracle_scalar(request_id_var.getvalue()))


def list_recent_research_requests(limit: int = 10) -> list[dict[str, object]]:
    sql = f"""
        SELECT * FROM (
            SELECT REQUEST_ID,
                   REQUEST_TYPE,
                   STATUS,
                   CREATED_AT,
                   DBMS_LOB.SUBSTR(RESULT_TEXT, 500, 1) AS RESULT_PREVIEW
            FROM {RESEARCH_REQUEST_TABLE}
            ORDER BY CREATED_AT DESC
        ) WHERE ROWNUM <= :limit
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"limit": limit})
            rows = cursor.fetchall()
    results = []
    for row in rows:
        result_preview = row[4] or ""
        match = re.search(r"Approval created:\s*(\d+)", result_preview, re.IGNORECASE)
        approval_id = int(match.group(1)) if match else None
        results.append(
            {
                "request_id": row[0],
                "request_type": row[1],
                "status": row[2],
                "created_at": row[3],
                "result_preview": result_preview,
                "approval_id": approval_id,
            }
        )
    return results
