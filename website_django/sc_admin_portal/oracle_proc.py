from __future__ import annotations

import logging
import os

import oracledb

from core.oracle_db import get_connection

JOB_TABLE = "PROC_GEMINI_JOBS"
APPROVAL_TABLE = "PROC_GEMINI_APPROVALS"

logger = logging.getLogger(__name__)


def _materialize_value(value):
    if hasattr(value, "read"):
        return value.read()
    return value


def _table_exists(cursor: oracledb.Cursor, table_name: str) -> bool:
    cursor.execute(
        "SELECT COUNT(1) FROM user_tables WHERE table_name = :name",
        {"name": table_name.upper()},
    )
    return cursor.fetchone()[0] > 0


def _column_exists(cursor: oracledb.Cursor, table_name: str, column_name: str) -> bool:
    cursor.execute(
        """
        SELECT COUNT(1)
        FROM user_tab_columns
        WHERE table_name = :table_name AND column_name = :column_name
        """,
        {"table_name": table_name.upper(), "column_name": column_name.upper()},
    )
    return cursor.fetchone()[0] > 0


def get_current_schema() -> str | None:
    if not (os.getenv("DB_USER") or os.getenv("ORACLE_USER")):
        return None
    try:
        with get_connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute("SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA') FROM dual")
                row = cursor.fetchone()
                return row[0] if row else None
    except Exception:
        logger.exception("proc_oracle.schema_lookup_failed")
        return None


def ensure_proc_tables_exist() -> None:
    ddl_jobs = f"""
    CREATE TABLE {JOB_TABLE} (
        JOB_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        ROUTINE_CODE VARCHAR2(50),
        ROUTINE_LABEL VARCHAR2(200),
        CONTENT_TEXT CLOB,
        INSTRUCTIONS CLOB NOT NULL,
        FILE_NAME VARCHAR2(512),
        FILE_MIME VARCHAR2(128),
        FILE_BLOB BLOB,
        STATUS VARCHAR2(30),
        CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
        UPDATED_AT TIMESTAMP,
        RESULT_TEXT CLOB,
        ERROR_TEXT CLOB
    )
    """

    ddl_approvals = f"""
    CREATE TABLE {APPROVAL_TABLE} (
        APPROVAL_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        SOURCE_JOB_ID NUMBER,
        REQUEST_TYPE VARCHAR2(50),
        TITLE VARCHAR2(512),
        PROPOSED_TEXT CLOB,
        DETAILS CLOB,
        GEMINI_COMMENTS CLOB,
        FILE_NAME VARCHAR2(512),
        FILE_MIME VARCHAR2(128),
        FILE_BLOB BLOB,
        STATUS VARCHAR2(30),
        CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
        DECIDED_AT TIMESTAMP,
        DECIDED_BY VARCHAR2(256),
        DECISION_NOTES CLOB
    )
    """

    with get_connection() as conn:
        with conn.cursor() as cursor:
            if not _table_exists(cursor, JOB_TABLE):
                cursor.execute(ddl_jobs)
            if not _table_exists(cursor, APPROVAL_TABLE):
                cursor.execute(ddl_approvals)
            elif not _column_exists(cursor, APPROVAL_TABLE, "GEMINI_COMMENTS"):
                cursor.execute(f"ALTER TABLE {APPROVAL_TABLE} ADD (GEMINI_COMMENTS CLOB)")
        conn.commit()


def insert_job(
    *,
    routine_code: str,
    routine_label: str,
    content_text: str | None,
    instructions: str,
    file_name: str | None,
    file_mime: str | None,
    file_blob: bytes | None,
) -> int:
    sql = f"""
        INSERT INTO {JOB_TABLE} (
            ROUTINE_CODE,
            ROUTINE_LABEL,
            CONTENT_TEXT,
            INSTRUCTIONS,
            FILE_NAME,
            FILE_MIME,
            FILE_BLOB,
            STATUS,
            CREATED_AT,
            UPDATED_AT
        )
        VALUES (
            :routine_code,
            :routine_label,
            :content_text,
            :instructions,
            :file_name,
            :file_mime,
            :file_blob,
            :status,
            SYSTIMESTAMP,
            SYSTIMESTAMP
        )
        RETURNING JOB_ID INTO :job_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            job_id_var = cursor.var(oracledb.NUMBER)
            cursor.execute(
                sql,
                {
                    "routine_code": routine_code,
                    "routine_label": routine_label,
                    "content_text": content_text,
                    "instructions": instructions,
                    "file_name": file_name,
                    "file_mime": file_mime,
                    "file_blob": oracledb.Binary(file_blob) if file_blob else None,
                    "status": "PENDING",
                    "job_id": job_id_var,
                },
            )
        conn.commit()
        return int(job_id_var.getvalue())


def list_recent_jobs(limit: int = 10) -> list[dict[str, object]]:
    sql = f"""
        SELECT * FROM (
            SELECT JOB_ID, ROUTINE_LABEL, STATUS, CREATED_AT, FILE_NAME
            FROM {JOB_TABLE}
            ORDER BY CREATED_AT DESC
        ) WHERE ROWNUM <= :limit
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"limit": limit})
            rows = cursor.fetchall()
    return [
        {
            "job_id": row[0],
            "routine_label": row[1],
            "status": row[2],
            "created_at": row[3],
            "file_name": row[4],
        }
        for row in rows
    ]


def list_pending_approvals(limit: int = 50) -> list[dict[str, object]]:
    with get_connection() as conn:
        with conn.cursor() as cursor:
            has_comments = _column_exists(cursor, APPROVAL_TABLE, "GEMINI_COMMENTS")
            comments_select = (
                "DBMS_LOB.SUBSTR(GEMINI_COMMENTS, 2000, 1) AS GEMINI_COMMENTS_PREVIEW"
                if has_comments
                else "CAST(NULL AS VARCHAR2(2000)) AS GEMINI_COMMENTS_PREVIEW"
            )
            sql = f"""
                SELECT * FROM (
                    SELECT APPROVAL_ID,
                           SOURCE_JOB_ID,
                           REQUEST_TYPE,
                           TITLE,
                           CREATED_AT,
                           FILE_NAME,
                           FILE_MIME,
                           DBMS_LOB.SUBSTR(PROPOSED_TEXT, 2000, 1) AS PROPOSED_TEXT_PREVIEW,
                           DBMS_LOB.SUBSTR(DETAILS, 2000, 1) AS DETAILS_PREVIEW,
                           {comments_select}
                    FROM {APPROVAL_TABLE}
                    WHERE UPPER(TRIM(STATUS)) = 'PENDING'
                    ORDER BY CREATED_AT DESC, APPROVAL_ID DESC
                ) WHERE ROWNUM <= :limit
            """
            try:
                cursor.execute(sql, {"limit": limit})
                rows = cursor.fetchall()
            except Exception:
                logger.exception("proc_oracle.list_pending_approvals_failed")
                raise
    results = []
    for row in rows:
        summary_source = row[3] or row[7] or row[8] or row[9] or ""
        results.append(
            {
                "approval_id": row[0],
                "source_job_id": row[1],
                "request_type": row[2],
                "title": row[3],
                "created_at": row[4],
                "file_name": row[5],
                "file_mime": row[6],
                "proposed_text_preview": row[7] or "",
                "details_preview": row[8] or "",
                "gemini_comments_preview": row[9] or "",
                "summary": summary_source,
            }
        )
    return results


def get_approval(approval_id: int) -> dict[str, object] | None:
    with get_connection() as conn:
        with conn.cursor() as cursor:
            if _column_exists(cursor, APPROVAL_TABLE, "GEMINI_COMMENTS"):
                comments_select = "GEMINI_COMMENTS"
            else:
                comments_select = "CAST(NULL AS CLOB) AS GEMINI_COMMENTS"
            sql = f"""
                SELECT APPROVAL_ID, SOURCE_JOB_ID, REQUEST_TYPE, TITLE, PROPOSED_TEXT, DETAILS,
                       {comments_select}, FILE_NAME, FILE_MIME, FILE_BLOB, STATUS, CREATED_AT, DECIDED_AT,
                       DECIDED_BY, DECISION_NOTES
                FROM {APPROVAL_TABLE}
                WHERE APPROVAL_ID = :approval_id
            """
            cursor.execute(sql, {"approval_id": approval_id})
            row = cursor.fetchone()
            if not row:
                return None
            materialized = [_materialize_value(value) for value in row]
    return {
        "approval_id": materialized[0],
        "source_job_id": materialized[1],
        "request_type": materialized[2],
        "title": materialized[3],
        "proposed_text": materialized[4],
        "details": materialized[5],
        "gemini_comments": materialized[6],
        "file_name": materialized[7],
        "file_mime": materialized[8],
        "file_blob": materialized[9],
        "status": materialized[10],
        "created_at": materialized[11],
        "decided_at": materialized[12],
        "decided_by": materialized[13],
        "decision_notes": materialized[14],
    }


def get_job_file(job_id: int) -> dict[str, object] | None:
    sql = f"""
        SELECT FILE_NAME, FILE_MIME, FILE_BLOB
        FROM {JOB_TABLE}
        WHERE JOB_ID = :job_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"job_id": job_id})
            row = cursor.fetchone()
            if not row or not row[2]:
                return None
            materialized = [_materialize_value(value) for value in row]
    return {
        "file_name": materialized[0],
        "file_mime": materialized[1],
        "file_blob": materialized[2],
    }


def get_approval_file(approval_id: int) -> dict[str, object] | None:
    sql = f"""
        SELECT FILE_NAME, FILE_MIME, FILE_BLOB
        FROM {APPROVAL_TABLE}
        WHERE APPROVAL_ID = :approval_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql, {"approval_id": approval_id})
            row = cursor.fetchone()
            if not row or not row[2]:
                return None
            materialized = [_materialize_value(value) for value in row]
    return {
        "file_name": materialized[0],
        "file_mime": materialized[1],
        "file_blob": materialized[2],
    }


def decide_approval(
    *,
    approval_id: int,
    status: str,
    decided_by: str,
    decision_notes: str | None,
) -> None:
    sql = f"""
        UPDATE {APPROVAL_TABLE}
        SET STATUS = :status,
            DECIDED_AT = SYSTIMESTAMP,
            DECIDED_BY = :decided_by,
            DECISION_NOTES = :decision_notes
        WHERE APPROVAL_ID = :approval_id
    """
    with get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute(
                sql,
                {
                    "status": status,
                    "decided_by": decided_by,
                    "decision_notes": decision_notes,
                    "approval_id": approval_id,
                },
            )
        conn.commit()


def list_recent_decisions(limit: int = 50) -> list[dict[str, object]]:
    sql = f"""
        SELECT * FROM (
            SELECT APPROVAL_ID, REQUEST_TYPE, TITLE, STATUS, DECIDED_AT, DECIDED_BY
            FROM {APPROVAL_TABLE}
            WHERE UPPER(TRIM(STATUS)) IN ('APPROVED', 'REJECTED')
            ORDER BY DECIDED_AT DESC NULLS LAST, CREATED_AT DESC
        ) WHERE ROWNUM <= :limit
    """
    try:
        with get_connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute(sql, {"limit": limit})
                rows = cursor.fetchall()
    except Exception:
        logger.exception("proc_oracle.list_recent_decisions_failed")
        raise
    return [
        {
            "approval_id": row[0],
            "request_type": row[1],
            "title": row[2],
            "status": row[3],
            "decided_at": row[4],
            "decided_by": row[5],
        }
        for row in rows
    ]
