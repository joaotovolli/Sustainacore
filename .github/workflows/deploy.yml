name: Deploy after Canary

on:
  workflow_run:
    workflows:
      - Canary + Self-Heal
    types:
      - completed
  workflow_dispatch:
    inputs:
      sha:
        description: Commit SHA to deploy (defaults to main head)
        required: false

concurrency:
  group: deploy-${{ github.event.workflow_run.head_branch || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write # allow deploy alerts to reach PRs

jobs:
  noop_on_skip:
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.gate.outputs.should_deploy }}
      reason: ${{ steps.gate.outputs.reason }}
    steps:
      - name: Evaluate deploy gate
        id: gate
        env:
          EVENT_NAME: ${{ github.event_name }}
          WORKFLOW_RUN_CONCLUSION: ${{ github.event.workflow_run.conclusion || '' }}
          WORKFLOW_RUN_EVENT: ${{ github.event.workflow_run.event || '' }}
          WORKFLOW_RUN_BRANCH: ${{ github.event.workflow_run.head_branch || '' }}
          WORKFLOW_RUN_SHA: ${{ github.event.workflow_run.head_sha || '' }}
          TARGET_SHA: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.event.inputs.sha || github.sha }}
          VM_HOST: ${{ secrets.VM_HOST }}
          VM_SSH_KEY: ${{ secrets.VM_SSH_KEY }}
        shell: bash
        run: |
          set -euo pipefail

          should="false"
          reasons=()

          if [[ "$EVENT_NAME" == "workflow_run" ]]; then
            if [[ "$WORKFLOW_RUN_CONCLUSION" != "success" ]]; then
              reasons+=("Upstream workflow concluded with '$WORKFLOW_RUN_CONCLUSION'.")
            fi
            if [[ "$WORKFLOW_RUN_EVENT" != "push" ]]; then
              reasons+=("Upstream workflow triggered by '$WORKFLOW_RUN_EVENT'; only push events are deployed.")
            fi
            if [[ "$WORKFLOW_RUN_BRANCH" != "main" ]]; then
              reasons+=("Upstream workflow targeted branch '$WORKFLOW_RUN_BRANCH'; only main is deployed.")
            fi
            if [[ ${#reasons[@]} -eq 0 ]]; then
              should="true"
            fi
          elif [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            reasons+=("Manual dispatch is disabled for deploys; rerun the Canary workflow on main.")
          else
            reasons+=("Unsupported triggering event '$EVENT_NAME'.")
          fi

          if [[ -z "${VM_HOST:-}" ]]; then
            reasons+=("Missing required secret 'VM_HOST'.")
          fi
          if [[ -z "${VM_SSH_KEY:-}" ]]; then
            reasons+=("Missing required secret 'VM_SSH_KEY'.")
          fi

          if [[ ${#reasons[@]} -ne 0 ]]; then
            should="false"
          fi

          if [[ "$should" == "true" ]]; then
            summary="### Deploy gate\nReady to deploy commit \`$TARGET_SHA\`."
            echo "Deploy gate passed; proceeding with deploy of $TARGET_SHA."
          else
            summary="### Deploy gate\nSkipping deploy for commit \`$TARGET_SHA\`."
            if [[ ${#reasons[@]} -gt 0 ]]; then
              summary+="\n\nReasons:"
              for reason in "${reasons[@]}"; do
                summary+="\n- ${reason}"
              done
            fi
            printf '%s\n' "Skipping deploy: ${reasons[*]:-no reasons recorded}."
          fi

          printf '%s\n' "$summary" >>"$GITHUB_STEP_SUMMARY"
          echo "should_deploy=$should" >>"$GITHUB_OUTPUT"
          if [[ ${#reasons[@]} -gt 0 ]]; then
            joined="${reasons[*]}"
            if [[ ${#reasons[@]} -gt 1 ]]; then
              joined=$(printf '%s; ' "${reasons[@]}")
              joined=${joined%'; '}
            fi
            printf 'reason=%s\n' "$joined" >>"$GITHUB_OUTPUT"
          else
            echo "reason=" >>"$GITHUB_OUTPUT"
          fi

  deploy:
    needs: noop_on_skip
    if: ${{ needs.noop_on_skip.outputs.should_deploy == 'true' }}
    runs-on: ubuntu-latest
    env:
      TARGET_SHA: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.event.inputs.sha || github.sha }}
    outputs:
      ready: ${{ steps.preflight.outputs.ready }}
      deploy-status: ${{ steps.run-deploy.outputs.status }}
      deploy-snippet: ${{ steps.run-deploy.outputs.snippet }}
    steps:
      - name: Preflight secrets
        id: preflight
        shell: bash
        env:
          VM_HOST: ${{ secrets.VM_HOST }}
          VM_SSH_KEY: ${{ secrets.VM_SSH_KEY }}
        run: |
          set -euo pipefail
          missing=()
          [[ -z "${VM_HOST:-}" ]] && missing+=("VM_HOST")
          [[ -z "${VM_SSH_KEY:-}" ]] && missing+=("VM_SSH_KEY")
          if ((${#missing[@]})); then
            {
              echo "### Deploy preflight";
              echo "Missing required secrets:";
              for secret in "${missing[@]}"; do
                echo "- \`${secret}\`";
              done;
            } >>"$GITHUB_STEP_SUMMARY"
            echo "ready=false" >>"$GITHUB_OUTPUT"
            exit 0
          fi
          echo "ready=true" >>"$GITHUB_OUTPUT"
      - name: Stop when secrets missing
        if: ${{ steps.preflight.outputs.ready != 'true' }}
        run: echo "Skipping deploy because required secrets are missing."
      - name: Checkout repository at canary commit
        if: ${{ steps.preflight.outputs.ready == 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ env.TARGET_SHA }}
          fetch-depth: 0
      - name: Write SSH key
        if: ${{ steps.preflight.outputs.ready == 'true' }}
        id: ssh-key
        shell: bash
        run: |
          set -euo pipefail
          key="$RUNNER_TEMP/vm_key"
          printf '%s\n' "${{ secrets.VM_SSH_KEY }}" >"$key"
          chmod 600 "$key"
          echo "path=$key" >>"$GITHUB_OUTPUT"
      - name: Run deploy script
        if: ${{ steps.preflight.outputs.ready == 'true' }}
        id: run-deploy
        shell: bash
        env:
          VM_HOST: ${{ secrets.VM_HOST }}
          SSH_KEY_PATH: ${{ steps.ssh-key.outputs.path }}
        run: |
          set -euo pipefail
          if [[ -z "${SSH_KEY_PATH:-}" ]]; then
            echo "SSH key path missing" >&2
            exit 1
          fi
          export VM_HOST
          export SSH_KEY="$SSH_KEY_PATH"
          chmod +x ops/scripts/deploy_vm.sh
          log_file="$RUNNER_TEMP/deploy.log"
          set +e
          ops/scripts/deploy_vm.sh 2>&1 | tee "$log_file"
          status=${PIPESTATUS[0]}
          set -e
          echo "status=$status" >>"$GITHUB_OUTPUT"
          if [[ $status -ne 0 ]]; then
            echo "snippet<<'EOF'" >>"$GITHUB_OUTPUT"
            tail -n 40 "$log_file" >>"$GITHUB_OUTPUT"
            echo 'EOF' >>"$GITHUB_OUTPUT"
          fi
      - name: Fail deploy if script errored
        if: ${{ steps.preflight.outputs.ready == 'true' && steps.run-deploy.outputs.status != '0' }}
        run: |
          echo "ops/scripts/deploy_vm.sh failed" >&2
          exit 1
      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f "${{ steps.ssh-key.outputs.path }}"
      - name: Deploy failure alert
        if: ${{ failure() && github.event_name == 'workflow_run' && steps.preflight.outputs.ready == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const prs = context.payload.workflow_run.pull_requests || [];
            if (!prs.length) {
              core.info('No pull request associated with the triggering canary.');
              return;
            }
            const marker = '<!-- deploy-alert -->';
            const issue_number = prs[0].number;
            const body = `${marker}
@joaotovolli @codex

ðŸš¨ **Deploy workflow failed** for canary commit \`${{ env.TARGET_SHA }}\`.

<details>
<summary>Error snippet</summary>

\`\`\`
${{ steps.run-deploy.outputs.snippet || 'See Actions logs for details.' }}
\`\`\`
</details>

ðŸ”— [Deploy logs](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})

**Fix Plan v1**
1. Codex: audit the failing deploy step and propose a targeted fix.
2. Push Attempt 1 with minimal changes and rerun the canary pipeline to retrigger deploy.
3. Update this comment with \`Attempt N â†’ result\` after each push (max 3).
4. If deploy stays red after Attempt 3, provide a rollback/manual recovery checklist.`;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              per_page: 100,
            });
            const existing = comments.find(comment => comment.body && comment.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                body,
              });
            }
      - name: Announce deploy success
        if: ${{ success() && github.event_name == 'workflow_run' && steps.preflight.outputs.ready == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const prs = context.payload.workflow_run.pull_requests || [];
            if (!prs.length) {
              core.info('No pull request to update for deploy success.');
              return;
            }
            const marker = '<!-- deploy-status -->';
            const issue_number = prs[0].number;
            const body = `${marker}
ðŸš€ Canary commit \`${{ env.TARGET_SHA }}\` deployed via ops/scripts/deploy_vm.sh.

_Run ID: [${context.runId}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})_`;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number,
              per_page: 100,
            });
            const existing = comments.find(comment => comment.body && comment.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                body,
              });
            }
